#include <iostream>
#include <ctime>
#include <cstdlib>

using namespace std;

struct Node //Структура с инфополями и адресным полем
{
    int data; //Инфополе. значения из x будут передаваться в список
    Node* Next; //Адресное поле
};

class List //Класс Список
{
    Node* Head; //Указатель на последний активный элемент или просто голова списка
public:
    List() { Head = NULL; } //Конструктор и инициализация указателя пустым значением
    ~List(); //Деструктор
    void push(int data); //Функция для добавления значений в список
    void show(); //Функция для отображения списка на экране
    int diff_count(); //Функция для подсчета различных значений
};

List::~List() //Деструктор
{
    while (Head != NULL) //Пока по адресу не пусто
    {
        Node* temp = Head->Next; //Временная переменная для хранения адреса следующего элемента
        delete Head; //Освобождаем адрес обозначающий начало
        Head = temp; //Меняем адрес на следующий
    }
}

void List::push(int data) //Функция добавления элементов в список
{
    Node* temp = new Node; //При каждом вызове выделяется память
    temp->data = data; //Записываем data в элемент структуры  Node (в data структуры Node)
    temp->Next = Head; //Указываем, что след. элемент это объект по адресу Head
    Head = temp; //Указываем, что последний активный элемент это только что введенный
}

void List::show() //Функция отображения списка на экране
{
    Node* temp = Head; //Определяем указатель, который изначально равен адресу начала списка

    while (temp != NULL) //До тех пор пока не встретит пустое значение
    {
        cout << temp->data << " "; //Выведет элемент x из списка
        temp = temp->Next; //Указываем, что далее нам нужен следующий элемент
    }
}

int List::diff_count() //Функция для подсчета различных значений
{
    Node* temp = Head; //Определяем указатель, который изначально равен адресу начала списка
    int count = 0; //Переменная для хранения кол-ва различных элементов
    bool flag; //Флаг проверки по каждому числу
    while (temp != NULL) //До тех пор пока не встретит пустое значение
    {
        flag = true; //Делаем заведомо истинным
        Node* tmp = temp->Next; //Указатель на следующий элемент
        while (tmp != NULL){ //Проходим по списку от следующего за текущим
            if(temp->data == tmp->data && temp != tmp){ //Проверяем чтобы данные были равны, а указатели нет
                flag = false; //Опускаем флаг если зашли
            }
            tmp = tmp->Next; //Двигаемся по списку
        }
        if(flag) //Если флаг остается истинным, значит мы не нашли повторов после нашего
            count++; //Увеличиваем счетчик
        temp = temp->Next; //Указываем, что далее нам нужен следующий элемент
    }
    return count; //Возвращаем кол-во
}

int main()
{
    int count; //Число элементов в список
    List lst; //Переменная, тип которой список
    srand(time(NULL)); //Инициализируем рандом по времени от начала запуска программы

    cout << "N = ";
    cin >> count; //Указали сколько элементов вводить в список

    for (int i = 0; i < count; i++) {
        int rand_data = rand()%9; //получаем рандомное значение
        lst.push(rand_data); //Добавление элемента в список
    }
    cout << "Different elements count - " << lst.diff_count() << endl;
    lst.show(); //Вывод списка на экран
}